# 运动目标识别
基本包括
- 摄像头调用
- 视频读取与保存
- 帧差法
- 光流法
- 背景减除法

## 开启摄像头

cap = cv2.VideoCapture(0)

cv2.VideoCapture()
- 参数 0,1 代表电脑的摄像头, 或者视频文件路径
ret,frame = cap.read()
- 逐帧读取视频
- ret 返回的bool，如果读取帧是正确的返回True，如果文件读取到结尾,返回False
- frame 每一帧的图片，是一个三维矩阵   

结束的时候，需要
cap.release()

## 保存视频
1. 指定写入视频编码方式
2. fourcc = cv2.VideoWriter.fourcc('M','J','P','G')
写入指定的编码格式


| 标志   | 作用  |
|  --------  | -------  |
| DIVX  | MPEG4 |
| MJPG  | JPEG 效果一般 |
| MP42  | MPEG-4.2  |
| DIV3  |  MPEG-4.3  |
|  U263 |  H263 |
|  I263 |  H263I |
|  FLV1 | FLV  |


## 保存视频
out = cv2.VideoWriter('路径+文件名',Fourcc 十字街编码格式,播放帧率,画幅大小用元组表示,是否彩色)

例如
out = cv2.VideoWriter('../test.avi',Fourcc,30.0,(640,480),True)

创建完成WV之后, out.write(frame)就可以了
如果要结束了之后，也需要和cap 一样release

-------------

## 帧差法
### 基本原理
对相邻或者相近帧数之间，取图像的灰度图，认为不动的物体灰度不发生变化，运动的物体灰度发生较为明显变化，因此可以直接对间隔帧之间，做差，从而得到运动物体的灰度图
#### 优点
- 算法简单
- 因为是灰度图，所以对光线的鲁棒性较好
#### 缺点
- 运动物体也只能检测轮廓，其内部会存在空洞
- 对于前后运动的物体检测较差，而对于相对画面上下左右 移动则较好
- 物体整体轮廓存，比实际大
- 快速运动的物体，存在糊影，可能会被识别成两个
- 慢速运动的物体，如果两帧重叠，就没办法识别
